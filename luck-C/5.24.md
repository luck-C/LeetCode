第一题 全排列 47
解题思路：
1.采用回溯+递归，一般回溯都会和递归一起使用。
2.由于给的数组中存在重复的数字，需要减枝。
3.定义一个boolean数组，原数组中使用过的数设置对应boolean数组下标为true，通过boolean数字的值筛检重复的组合。
代码如下：
class Solution {
    public List<List<Integer>> result = new LinkedList<>();
    public List<List<Integer>> permuteUnique(int[] nums) {
        if(nums.length == 0){
            return result;
        }
        //首先给数组排序
        Arrays.sort(nums);
        findUnique(nums,new boolean[nums.length],new LinkedList<Integer>());
        return result;
    }
    public void findUnique(int[] nums, boolean[] visited,LinkedList<Integer> trace){
       if(trace.size() == nums.length) {
           result.add(new LinkedList<>(trace));
            return;
       }
       for(int i = 0;i<nums.length;i++){
           if(visited[i]) continue;
           if(i>0 && nums[i] == nums[i-1] && !visited[i-1]) continue;
           trace.add(nums[i]);
           visited[i] = true;
           findUnique(nums,visited,trace);
           visited[i] = false;
           trace.removeLast();
       }
    }
}
第二题 全排列 46
解题思路：
1.是第一题的简单版，回溯+递归解决。
代码如下：
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> permute(int[] nums) {
        List<Integer> list = new ArrayList<>();
        trackBack(nums,list);
        return res;
        
    }
    private void trackBack(int[] nums,List<Integer> list){
        if(list.size() == nums.length){
            res.add(new ArrayList<>(list));
        }
        for(int i = 0;i<nums.length;i++){
            if(list.contains(nums[i])) continue;
            list.add(nums[i]);
            trackBack(nums,list);
            list.remove(list.size()-1);
        }
    }
    
}
第三题 寻找两个正序数组的中位数 4
解题思路：
1.由于都是有序数组，所以可以从下标0开始向右判断。
2.不需要合并数组，双指针法，符合条件移动并记录下值。
3.确定中位数的方法：
将长度&1，不为0则为偶数，中位数的值=（left+right）/2；
为0，中位数的值位right。
代码如下：
class Solution {
    public double findMedianSortedArrays(int[] A, int[] B) {
    int m = A.length;
    int n = B.length;
    int len = m + n;
    int left = -1;
    int right = -1;
    int aStart = 0;
    int bStart = 0;
    for(int i = 0;i<= len/2;i++){
        left = right;
        if(aStart < m && (bStart >= n || A[aStart] < B[bStart])){
            right = A[aStart++];
        }else{
            right = B[bStart++];
        }
    }
    if((len & 1 )== 0){
        return (double)(left + right)/2;
    }else{
        return right;
    }
}
