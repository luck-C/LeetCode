第一题 可以被k整除的子数组 974
解题思路：
1.采用前缀法和同余和。
2.当num[3]+num[4]可以被k整除时，（num[1]+num[2]+num[3]+num[4]）%k==（num[1]+num[2]）%k。因此当出现相同的余数时证明必有一个子数组符合条件。
3.注意余数的符号，为了保证余数符号相同，取余后+K再次取余。
4.注意map的getOrDefault(,)方法。
5.注意设置初始值，余数为0时的初始数。
代码如下：
class Solution {
    public int subarraysDivByK(int[] A, int K) {
        
       Map<Integer,Integer> map = new HashMap<>();
       int res = 0;
       int sum = 0;
       map.put(0,1);
       for(int num:A){
           sum += num;
           int tem = (sum%K+K)%K;
           int count = map.getOrDefault(tem,0);
           res += count;
            map.put(tem,count+1);
       }
       return res;
    }
}
第二题 62 不同路径
解题思路：
1.由于只能往右和下走，不能后退，所以走到任何一个边缘地区的路径都为1.
2.非边缘地区的路线为从上方到达的路线数+从左边到达的路线数。
代码如下：
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for(int i = 0;i<m;i++) dp[i][0] = 1;
        for(int i = 0;i<n;i++) dp[0][i] = 1;
        for(int i = 1;i<m;i++){
            for(int j = 1;j<n;j++){
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        } 
        return dp[m-1][n-1];
    }
}
第三题 最小路径和 64
1.分为边缘和非边缘的情况。
2.边缘的最小路径都为上一个路径的相加。
3.非边缘情况的最小路径为左边路径与上边路径的最小值。
代码如下：
class Solution {
    public int minPathSum(int[][] grid) {
        
        int len = grid[0].length;
        int height = grid.length;
        int[][] dp = new int[height][len];
        dp[0][0] = grid[0][0];
        for(int i = 1;i<len;i++) dp[0][i] = dp[0][i-1]+grid[0][i];
        for(int j = 1;j<height;j++) dp[j][0] = dp[j-1][0] + grid[j][0];
        for(int i = 1;i<height;i++){
            for(int j = 1;j<len;j++){
                dp[i][j] = Math.min(dp[i-1][j],dp[i][j-1])+grid[i][j];
            }
        }
        return dp[height-1][len-1]; 

    }
}
