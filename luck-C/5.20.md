第一题 岛屿的周长 463
解题思路：
1.判断是不是1，默认4条边，如果每相邻的有1，则减去一条。
代码如下：
class Solution {
    public int islandPerimeter(int[][] grid) {
        if(grid.length == 0) return 0;
        int len = grid[0].length;
        int height = grid.length;
       
        
        int sum = 0;
        for(int i = 0;i<height;i++){
            for(int j =0;j < len;j++){
                if(grid[i][j] == 1){
                    int count = 4;
                    if(  i>0 && grid[i-1][j] == 1) count--;
                    if(i <height-1 && grid[i+1][j] == 1 ) count--;
                    if(j >0 && grid[i][j-1] == 1 ) count--;
                    if(j < len-1 && grid[i][j+1] == 1) count--;
                    sum += count;
                }
                }
            }
            return sum;
        }

    }
    第二题 二叉树中的插入操作 701
    解题思路：
    1.首先与根节点比较，小的往左，大的往右。遍历。
    代码如下：
    class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        return help(root,val);
    }
    private TreeNode help(TreeNode root,int val){
        if(root == null){
            root = new TreeNode(val);
        }else if( root.val > val){
            root.left = help(root.left,val);
        }else{
            root.right = help(root.right,val);
        }
        return root;
    }
}
第三题 1335 工作计划的最低难度
解题思路：
1.采用动态规划法。
2.每次记录当前完成当前任务前一个的最大难度，存入数组。
3.每次遍历所拥有的天数加1.
代码如下：
class Solution {
    public int minDifficulty(int[] jobDifficulty, int d) {
        int len = jobDifficulty.length;
        if(len < d) return -1;
        int[] dp = new int[len];
        dp[0] = jobDifficulty[0];
        for(int i = 1;i<len;i++){
            dp[i] = Math.max(jobDifficulty[i],dp[i-1]);
        }
        //每循环一边dp[j] = 值都会变成n+1天的情况
        for(int i = 1;i<d;i++){
            for(int j = len-1;j>=i;j--){
                int most = jobDifficulty[j];
                dp[j] = Integer.MAX_VALUE;
                for(int k = j;k>=i;k--){
                    most = Math.max(most,jobDifficulty[k]);
                    dp[j] = Math.min(dp[j],dp[k-1]+most);
                }
            }
        }
        return dp[len-1];
    }
}
