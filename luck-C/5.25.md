第一题 字母异味词分组 49
解题思路：
1.采用map<String,List<String>>的形式来保存结果；
2.遍历数组，将每个字符串转成数组再排序，再转回字符串，看看map中是否存在对应的key；
3.存在，将字符串加入对应数组；
4.不存在，创建一个新的数组来保存。
代码如下：
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String,List<String>> map=new HashMap<>();
        for (String str:strs){
            char [] s= str.toCharArray();
            Arrays.sort(s);
            String find=new String(s);
            if (map.containsKey(find)){
                List<String> arr=map.get(find);
                arr.add(str);
                map.put(find,arr);
            }
            else{
                List<String> arr=new ArrayList<>();
                arr.add(str);
                map.put(find,arr);
            }
        }
        return new ArrayList<>(map.values());
    }
}
第二题 旋转图像 48
解题思路：
1.通过定两个对角坐标来确定基准点进行旋转；
代码如下：
class Solution {
   public void rotate(int[][] matrix) {
        if (matrix == null || matrix.length == 0) {
            return;
        }
        int rowStart = 0;
        int colStart = 0;
        int rowEnd = matrix.length - 1;
        int colEnd = matrix[0].length - 1;

        while (rowStart < rowEnd) {
            help(matrix,rowStart,colStart,rowEnd,colEnd);
            rowStart++;
            colStart++;
            rowEnd--;
            colEnd--;
        }
    }

    private void help(int[][] matrix, int rowStart, int colStart, int rowEnd, int colEnd) {
        int time = rowEnd - rowStart;
        for (int i = 0; i < time; i++) {
            int tmp = matrix[rowStart][colStart + i];
            matrix[rowStart][colStart + i] = matrix[rowEnd - i][colStart];
            matrix[rowEnd - i][colStart] = matrix[rowEnd][colEnd - i];
            matrix[rowEnd][colEnd - i] = matrix[rowStart + i][colEnd];
            matrix[rowStart + i][colEnd] = tmp;

        }
    }
}
第三题 146 LRU缓存机制
解题思路：
1.使用链表+hash结构来存储值。
2.get操作：
每次操作数之后要把操作的节点放到链表的首位。
put操作：
判断是否超过规定长度，超过则将最后一个节点删除，然后将新的节点放入到链表头；
代码如下：
class LRUCache {
    //LRUCash属性
    private Map<Integer,ListNode> map;
    private int capacity;
    //虚拟头节点
    private ListNode dummyHead;
    //虚拟尾节点
    private ListNode dummyTail;

    
    
    //链表节点
    class ListNode{
        private Integer key;
        private Integer value;
        private ListNode pre;
        private ListNode next;
        public ListNode(){}
        public ListNode(int key,int value){
            this.key = key;
            this.value = value;
        }
    }

    public LRUCache(int capacity) {
        map = new HashMap<>(capacity);
        this.capacity =capacity;
        //初始化双向链表
        dummyHead = new ListNode(-1,-1);
        dummyTail = new ListNode(-1,-1);
        dummyHead.next = dummyTail;
        dummyTail.pre = dummyHead;
    }
    
    public int get(int key) {
        if(map.containsKey(key)){
            //拿到之后将该节点放到头节点
            ListNode node = map.get(key);
            int val = node.value;
            moveNode2Head(key);
            return val;
        }else {
            return -1;
        }
    }
    
    public void put(int key, int value) {
        //先判断是否重复
        if(map.containsKey(key)){
            //重复则覆盖，并移到头节点
            map.get(key).value = value;
            moveNode2Head(key);
            return;
        }//判断是否超出容量限制
        if(map.size() == capacity){
            ListNode oldTail = removeTail();
            map.remove(oldTail.key);
        }
        //添加元素
        ListNode newNode = new ListNode(key,value);
        map.put(key,newNode);
        addNode2Head(newNode);
    }
    //三个公用方法
    private ListNode removeTail(){
        ListNode oldTail = dummyTail.pre;
        oldTail.pre.next = dummyTail;
        dummyTail.pre = oldTail.pre;
        //隔离原来尾节点
        oldTail.next = null;
        oldTail.pre = null;
        return oldTail;
    }
    private void moveNode2Head(int key){
        ListNode node = map.get(key);
        //处理上下节点
        node.pre.next = node.next;
        node.next.pre = node.pre;
        //移动到头节点
        ListNode oldHead = dummyHead.next;
        dummyHead.next = node;
        node.pre = dummyHead;
        node.next = oldHead;
        oldHead.pre = node;
    }
    private void addNode2Head(ListNode newNode){
        ListNode oldHead = dummyHead.next;
        oldHead.pre = newNode;
        newNode.next = oldHead;
        dummyHead.next = newNode;
        newNode.pre = dummyHead;
    }


   
}
