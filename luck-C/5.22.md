第一题 105 从前序与中序遍历构造二叉树
解题思路：
1.前序确定根节点的值，在中序找到根节点的下标，组合。
2.优化是将中序遍历的数组放到map中，这样不用遍历可以直接取到下标。
代码如下：
class Solution {
    // 跟踪根节点的值
    int i = 0;
    Map<Integer,Integer> map;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        map = new HashMap<>();
        for(int i = 0;i<inorder.length;i++){
            map.put(inorder[i],i);
        }
        return creat(preorder,inorder,0,preorder.length-1);
    }
    private TreeNode creat(int[] preorder,int[] inorder,int left,int right){
        if(left > right) return null;
        int j = map.get(preorder[i]);

        
        TreeNode root = new TreeNode(preorder[i++]);
        root.left = creat(preorder,inorder,left,j-1);
        root.right = creat(preorder,inorder,j+1,right);
        return root;
    }
}
第二题 106 从中序遍历序列与后序构造二叉树
解题思路：
1.与第一题相识，区别在于后序遍历根节点要从后开始，并且需要先构造右子树
代码如下：
class Solution {
    int i;
    Map<Integer,Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        i = postorder.length-1;
        
        for(int i = 0;i<inorder.length;i++){
            map.put(inorder[i],i);
        }
        return creat(inorder,postorder,0,postorder.length-1);
    }
    private TreeNode creat(int[] inorder,int[] postorder,int left,int right){
        if(left > right) return null;
        int j = map.get(postorder[i]);
        
        TreeNode root = new TreeNode(postorder[i--]);
         root.right = creat(inorder,postorder,j+1,right);
        root.left = creat(inorder,postorder,left,j-1);
       
        return root;
    }
}
第三题 组合总和 39
解题思路：
1.采用回溯+递归。
代码如下：
class Solution {
   List<List<Integer>> lists = new ArrayList<>();

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        if(candidates == null || candidates.length==0||target<0) return lists;
        List<Integer> list = new ArrayList<>();
        process(0,candidates,target,list);
        return lists;
        
    }
    private void process(int start,int[] candidates,int target,List<Integer> list){
        if(target < 0) return;
        if(target == 0) lists.add(new ArrayList<>(list));
        else{
            for(int i = start;i<candidates.length;i++){
                list.add(candidates[i]);
                process(i,candidates,target-candidates[i],list);
                list.remove(list.size()-1);
            }
        }
    }
}
